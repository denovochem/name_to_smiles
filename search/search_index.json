{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Quick Start","text":"<p>Install cholla_chem with pip directly from the github repo:</p> <pre><code>pip install git+https://github.com/denovochem/cholla_chem.git\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>Resolve chemical names to SMILES by passing a string or a list of strings: <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(['aspirin'])\n\n\"{'aspirin': 'CC(=O)Oc1ccccc1C(=O)O'}\"\n</code></pre></p> <p>See detailed information including which resolver returned which SMILES with detailed_name_dict=True: <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['2-acetyloxybenzoic acid'], \n    detailed_name_dict=True\n)\n\n\"{'2-acetyloxybenzoic acid': {\n    'SMILES': 'CC(=O)Oc1ccccc1C(=O)O',\n    'SMILES_source': ['pubchem_default', 'opsin_default'],\n    'SMILES_dict': {\n        'CC(=O)Oc1ccccc1C(=O)O': ['pubchem_default', 'opsin_default']\n    },\n    'info_messages': {}\n}}\"\n</code></pre></p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Resolve chemical names to SMILES by passing a string or a list of strings: <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(['aspirin'])\n\n\"{'aspirin': 'CC(=O)Oc1ccccc1C(=O)O'}\"\n</code></pre></p> <p>See detailed information including which resolver returned which SMILES with detailed_name_dict=True: <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['2-acetyloxybenzoic acid'], \n    detailed_name_dict=True\n)\n\n\"{'2-acetyloxybenzoic acid': {\n    'SMILES': 'CC(=O)Oc1ccccc1C(=O)O',\n    'SMILES_source': ['pubchem_default', 'opsin_default'],\n    'SMILES_dict': {\n        'CC(=O)Oc1ccccc1C(=O)O': ['pubchem_default', 'opsin_default']\n    },\n    'info_messages': {}\n}}\"\n</code></pre></p>"},{"location":"getting_started/#advanced-usage","title":"Advanced usage","text":"<p>Many aspects of the name-to-SMILES resolution process can be customized, including the resolvers that are used, the configuration of those resolvers, and the strategy used to pick the best SMILES.</p> <p>In this example, we resolve chemical names with OPSIN, PubChem, and CIRPy, and use a custom consensus weighting approach to pick the best SMILES: <pre><code>from cholla_chem import resolve_compounds_to_smiles\nfrom cholla_chem import (\n    OpsinNameResolver, \n    PubChemNameResolver, \n    CIRpyNameResolver\n)\n\nopsin_resolver = OpsinNameResolver(\n    resolver_name='opsin', \n    resolver_weight=4\n)\npubchem_resolver =  PubChemNameResolver(\n    resolver_name='pubchem', \n    resolver_weight=3\n)\ncirpy_resolver = CIRpyNameResolver(\n    resolver_name='cirpy', \n    resolver_weight=2\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['2-acetyloxybenzoic acid'],\n    [opsin_resolver, pubchem_resolver, cirpy_resolver],\n    smiles_selection_mode='weighted',\n    detailed_name_dict=True\n)\n\n\"{'2-acetyloxybenzoic acid': {\n    'SMILES': 'CC(=O)Oc1ccccc1C(=O)O',\n    'SMILES_source': ['opsin', 'pubchem', 'cirpy'],\n    'SMILES_dict': {\n        'CC(=O)Oc1ccccc1C(=O)O': ['opsin', 'pubchem', 'cirpy']\n    },\n    'info_messages': {}\n}}\"\n</code></pre></p> <p>More information about advanced usage can be found in Resolvers, Smiles Selection, and Name Correction/Editing</p>"},{"location":"installation/","title":"Installation","text":"<p>core supports Python versions &gt;=3.10. There are no required python dependencies. Java 8+ is required to run OPSIN.</p>"},{"location":"installation/#installation-option-1-use-pip-recommended","title":"Installation Option #1: Use pip (recommended)","text":"<p>Install core with pip directly from the github repo:</p> <pre><code>pip install git+https://github.com/denovochem/cholla_chem.git\n</code></pre>"},{"location":"installation/#installation-option-2-clone-the-repository","title":"Installation Option #2: Clone the repository","text":"<p>Install the latest version of core from GitHub. The version on GitHub is not guaranteed to be stable, but may include new features not available using other install options. Clone the repository and install:</p> <pre><code>git clone https://github.com/denovochem/cholla_chem.git\ncd cholla_chem\npip install .\n</code></pre>"},{"location":"name_manipulation/","title":"Name manipulation","text":"<p>This package contains utilities that automatically attempt to transform or correct input names if the initial name-to-SMILES conversion fails. At the moment there are two major capabilities:</p> <ul> <li>Splitting on delimiters (e.g. 'BH3\u2022THF' \u2192 'BH3' and 'THF')</li> <li>Peptide shorthand expansion (e.g. <code>Boc-Ala-Gly-OMe</code> \u2192 <code>tert-butoxycarbonyl-l-alanyl-glycine methyl ester</code>)</li> <li>Chemical name correction (primarily aimed at OCR/typo artifacts, with validation via OPSIN)</li> </ul> <p>Each of these name manipulations is enabled by default, but can be disabled by setting the corresponding argument to False.</p>"},{"location":"name_manipulation/#splitting-on-delimiters","title":"Splitting on delimiters","text":"<p>Split chemical names on common delimiters and then solve each component separately.</p> <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(['BH3\u2022THF'], split_names_to_solve=True)\n\n\"{'BH3\u2022THF': 'B.C1CCOC1'}\"\n</code></pre>"},{"location":"name_manipulation/#peptide-shorthand-expansion","title":"Peptide shorthand expansion","text":"<p>Applied when a chemical name looks like peptide shorthand, typically containing amino-acid abbreviations delimited by hyphens, such as:</p> <ul> <li><code>Ala-Gly-Ser</code></li> <li><code>Boc-Asp-Lys(Boc)-OMe</code></li> <li><code>cyclo(Ala-Gly-Ser)</code> or <code>cyclo[Ala-Gly-Ser]</code></li> </ul> <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(['cyclo(Asp-Arg-Val-Tyr-Ile-His-Pro-Phe)'], resolve_peptide_shorthand=True)\n\n\"{'cyclo(Asp-Arg-Val-Tyr-Ile-His-Pro-Phe)': 'BN1[C@@H](CC(=O)O)C(=O)N[C@@H](CCCNC(N)=N)C(=O)N[C@@H](C(C)C)C(=O)N[C@@H](CC2=CC=C(C=C2)O)C(=O)N[C@@H]([C@@H](C)CC)C(=O)N[C@@H](CC2=CNC=N2)C(=O)N2[C@@H](CCC2)C(=O)N[C@@H](CC2=CC=CC=C2)C1=O'}\"\n</code></pre>"},{"location":"name_manipulation/#chemical-name-correction","title":"Chemical name correction","text":"<p>Applied when a chemical name looks like it might have OCR/typo artifacts, with validation via OPSIN.</p> <ul> <li>Examples of artifacts:</li> <li><code>3,4-dihydro- 3-hydroxy-4-oxo-l,2,3-benzotriazine</code> \u2192 <code>3,4-dihydro- 3-hydroxy-4-oxo-1,2,3-benzotriazine</code></li> <li><code>ethyl perfiuorobutyrate</code> \u2192 <code>ethyl perfluorobutyrate</code></li> <li><code>l-mercapto-Z-thiapropane</code> \u2192 <code>1-mercapto-2-thiapropane</code></li> </ul> <pre><code>from cholla_chem import resolve_compounds_to_smiles\n\nresolved_smiles = resolve_compounds_to_smiles(['l-mercapto-Z-thiapropane'], attempt_name_correction=True)\n\n\"{'l-mercapto-Z-thiapropane': 'SCSC'}\"\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#cholla_chem","title":"<code>cholla_chem</code>","text":"<p>cholla_chem initialization.</p>"},{"location":"reference/#cholla_chem.CIRpyNameResolver","title":"<code>CIRpyNameResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using Chemical Identity Resolver via CIRPy.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class CIRpyNameResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using Chemical Identity Resolver via CIRPy.\n    \"\"\"\n\n    def __init__(self, resolver_name: str, resolver_weight: float = 1):\n        super().__init__(\"cirpy\", resolver_name, resolver_weight)\n\n    def name_to_smiles(\n        self, compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using cirpy.\n        \"\"\"\n        resolved_names = name_to_smiles_cirpy(compound_name_list)\n        return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.CIRpyNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>","text":"<p>Convert chemical names to SMILES using cirpy.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self, compound_name_list: List[str]\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using cirpy.\n    \"\"\"\n    resolved_names = name_to_smiles_cirpy(compound_name_list)\n    return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector","title":"<code>ChemNameCorrector</code>","text":"<p>Main class for correcting OCR errors in chemical names.</p> <p>This class orchestrates the correction process by: 1. Applying configured correction strategies 2. Generating candidate corrections 3. Scoring candidates 4. Optionally validating with external tools 5. Returning ranked results</p> Example <p>corrector = ChemNameCorrector() results = corrector.correct(\"2-ch1oropropanoic acid\") print(results[0].name) 2-chloropropanoic acid</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>Configuration for the corrector</p> <code>strategies</code> <p>List of active correction strategies</p> <code>scorer</code> <p>Scoring instance for ranking candidates</p> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>class ChemNameCorrector:\n    \"\"\"\n    Main class for correcting OCR errors in chemical names.\n\n    This class orchestrates the correction process by:\n    1. Applying configured correction strategies\n    2. Generating candidate corrections\n    3. Scoring candidates\n    4. Optionally validating with external tools\n    5. Returning ranked results\n\n    Example:\n        &gt;&gt;&gt; corrector = ChemNameCorrector()\n        &gt;&gt;&gt; results = corrector.correct(\"2-ch1oropropanoic acid\")\n        &gt;&gt;&gt; print(results[0].name)\n        2-chloropropanoic acid\n\n        &gt;&gt;&gt; # With custom configuration\n        &gt;&gt;&gt; config = CorrectorConfig(max_candidates=50)\n        &gt;&gt;&gt; corrector = ChemNameCorrector(config)\n\n        &gt;&gt;&gt; # With external validation\n        &gt;&gt;&gt; validator = PubChemValidator()\n        &gt;&gt;&gt; results = corrector.correct(\"asprin\", validator=validator)\n\n    Attributes:\n        config: Configuration for the corrector\n        strategies: List of active correction strategies\n        scorer: Scoring instance for ranking candidates\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[CorrectorConfig] = None,\n        strategies: Optional[List[CorrectionStrategy]] = None,\n    ):\n        \"\"\"\n        Initialize the chemical name corrector.\n\n        Args:\n            config: Configuration object (uses defaults if None)\n            strategies: Custom list of strategies (uses defaults if None)\n        \"\"\"\n        self.config = config or CorrectorConfig()\n        self.scorer = ChemicalNameScorer(self.config)\n\n        if strategies is not None:\n            self.strategies = strategies\n        else:\n            self.strategies = self._create_default_strategies()\n\n        self.validator = None\n        if self.config.enable_external_validation:\n            self.validator = OPSINValidator()\n\n    def _create_default_strategies(self) -&gt; List[CorrectionStrategy]:\n        \"\"\"Create the default set of correction strategies based on config.\"\"\"\n        strategies: List[CorrectionStrategy] = []\n\n        if self.config.enable_locant_correction:\n            strategies.append(LocantCorrectionStrategy())\n\n        if self.config.enable_character_substitution:\n            char_strategy = CharacterSubstitutionStrategy(\n                max_edits=self.config.max_character_substitution_edits\n            )\n            # Add any custom substitutions\n            for orig, replacements in self.config.custom_substitutions.items():\n                char_strategy.add_substitution(orig, replacements)\n            strategies.append(char_strategy)\n\n        if self.config.enable_punctuation_restoration:\n            strategies.append(PunctuationRestorationStrategy())\n\n        if self.config.enable_bracket_balancing:\n            strategies.append(BracketBalancingStrategy())\n\n        return strategies\n\n    def add_strategy(self, strategy: CorrectionStrategy) -&gt; None:\n        \"\"\"\n        Add a custom correction strategy.\n\n        Args:\n            strategy: The strategy to add\n        \"\"\"\n        self.strategies.append(strategy)\n\n    def remove_strategy(self, strategy_name: str) -&gt; bool:\n        \"\"\"\n        Remove a strategy by name.\n\n        Args:\n            strategy_name: Name of the strategy to remove\n\n        Returns:\n            True if strategy was found and removed, False otherwise\n        \"\"\"\n        for i, strategy in enumerate(self.strategies):\n            if strategy.name == strategy_name:\n                self.strategies.pop(i)\n                return True\n        return False\n\n    def correct(\n        self, name: str, use_validator: bool = True, validate_all: bool = False\n    ) -&gt; List[CorrectionCandidate]:\n        \"\"\"\n        Correct a chemical name and return ranked candidates.\n\n        Args:\n            name: The chemical name to correct\n            use_validator: Whether to use external validator\n            validate_all: Whether to validate all candidates or just the top ones\n\n        Returns:\n            List of CorrectionCandidate objects, sorted by score (descending)\n        \"\"\"\n        # Generate all candidates\n        candidates = self._generate_all_candidates(name)\n\n        # Remove duplicates while preserving best corrections\n        unique_candidates = self._deduplicate_candidates(candidates)\n\n        # Score all candidates\n        scored_candidates = [\n            self.scorer.score(candidate) for candidate in unique_candidates\n        ]\n\n        # Filter by minimum score threshold\n        filtered_candidates = [\n            c for c in scored_candidates if c.score &gt;= self.config.min_score_threshold\n        ]\n\n        # Sort by score (descending)\n        sorted_candidates = sorted(\n            filtered_candidates, key=lambda c: c.score, reverse=True\n        )\n\n        # Limit to max candidates\n        limited_candidates = sorted_candidates[: self.config.max_candidates]\n\n        if use_validator:\n            self._validate_candidates_batch(\n                {name: limited_candidates}, self.validator, validate_all\n            )\n\n            limited_candidates = sorted(\n                limited_candidates, key=lambda c: c.score, reverse=True\n            )\n\n        return limited_candidates\n\n    def correct_batch(\n        self, names: List[str], use_validator: bool = True, validate_all: bool = False\n    ) -&gt; Dict[str, List[CorrectionCandidate]]:\n        \"\"\"\n        Correct multiple chemical names.\n\n        Args:\n            names: List of chemical names to correct\n            use_validator: Whether to use external validator\n            validate_all: Whether to validate all candidates or just the top ones\n\n        Returns:\n            Dictionary mapping original names to their candidates\n        \"\"\"\n        results = {}\n        for name in names:\n            results[name] = self.correct(name, use_validator=False)\n\n        if use_validator:\n            self._validate_candidates_batch(results, self.validator, validate_all)\n\n        for name in names:\n            results[name] = sorted(results[name], key=lambda c: c.score, reverse=True)\n\n        return results\n\n    def _generate_all_candidates(self, name: str) -&gt; List[CorrectionCandidate]:\n        \"\"\"Generate candidates from all strategies.\"\"\"\n        candidates: List[CorrectionCandidate] = []\n\n        # Apply each strategy\n        current_texts: List[Tuple[str, List[Correction]]] = [\n            (name, [])\n        ]  # (text, corrections)\n        for strategy in self.strategies:\n            new_texts = []\n\n            for text, existing_corrections in current_texts:\n                new_texts.append((text, existing_corrections))\n                for new_text, new_corrections in strategy.generate_candidates(\n                    text, self.config\n                ):\n                    combined_corrections = existing_corrections + new_corrections\n\n                    # Check max corrections limit\n                    if (\n                        len(combined_corrections)\n                        &lt;= self.config.max_corrections_per_candidate\n                    ):\n                        new_texts.append((new_text, combined_corrections))\n\n                        candidates.append(\n                            CorrectionCandidate(\n                                name=new_text,\n                                original_name=name,\n                                corrections=combined_corrections,\n                            )\n                        )\n\n            # Update current texts for next strategy\n            # Limit to prevent explosion\n            current_texts = new_texts[: self.config.max_candidates * 2]\n\n        return candidates\n\n    def _deduplicate_candidates(\n        self, candidates: List[CorrectionCandidate]\n    ) -&gt; List[CorrectionCandidate]:\n        \"\"\"Remove duplicate candidates, keeping the one with fewer corrections.\"\"\"\n        seen: Dict[str, CorrectionCandidate] = {}\n\n        for candidate in candidates:\n            if candidate.name not in seen:\n                seen[candidate.name] = candidate\n            else:\n                # Keep the one with fewer corrections\n                if candidate.num_corrections &lt; seen[candidate.name].num_corrections:\n                    seen[candidate.name] = candidate\n\n        return list(seen.values())\n\n    def _validate_candidates_batch(\n        self,\n        candidates: Dict[str, List[CorrectionCandidate]],\n        validator: Optional[Validator],\n        validate_all: bool,\n    ) -&gt; None:\n        \"\"\"Validate candidates using external validator.\"\"\"\n        if not validator:\n            return\n\n        all_candidate_names = []\n        original_name_candidate_name_map = {}\n        candidate_name_candidate_object_map = {}\n        for original_name, candidates_list in candidates.items():\n            original_name_candidate_name_map[original_name] = [\n                candidate.name for candidate in candidates_list\n            ]\n            candidate_name_candidate_object_map.update(\n                {candidate.name: candidate for candidate in candidates_list}\n            )\n            all_candidate_names.extend(\n                [candidate.name for candidate in candidates_list]\n            )\n\n        validator_outputs = validator.batch_validate(all_candidate_names)\n\n        for candidate_name, (is_valid, result) in validator_outputs.items():\n            candidate = candidate_name_candidate_object_map[candidate_name]\n            candidate.validated = True\n            candidate.validation_result = result\n\n            if is_valid:\n                # Boost score for valid candidates\n                candidate.score = min(1.0, candidate.score + 0.3)\n\n            else:\n                # Lower score for invalid candidates\n                candidate.score = max(0.0, candidate.score - 0.2)\n\n        return\n\n    def get_best_candidate(\n        self, name: str, use_validator: bool = True\n    ) -&gt; Optional[CorrectionCandidate]:\n        \"\"\"\n        Get the single best correction candidate.\n\n        Args:\n            name: Chemical name to correct\n            validator: Optional external validator\n\n        Returns:\n            Best candidate, or None if no candidates found\n        \"\"\"\n        candidates = self.correct(name, use_validator)\n        return candidates[0] if candidates else None\n\n    def explain_corrections(self, candidate: CorrectionCandidate) -&gt; str:\n        \"\"\"\n        Generate a human-readable explanation of corrections.\n\n        Args:\n            candidate: The candidate to explain\n\n        Returns:\n            Multi-line string explaining all corrections\n        \"\"\"\n        lines = [\n            f\"Original: {candidate.original_name}\",\n            f\"Corrected: {candidate.name}\",\n            f\"Score: {candidate.score:.3f}\",\n            f\"Number of corrections: {candidate.num_corrections}\",\n            \"\",\n            \"Score components:\",\n        ]\n\n        for component, value in candidate.score_components.items():\n            lines.append(f\"  - {component}: {value:.3f}\")\n\n        if candidate.corrections:\n            lines.append(\"\")\n            lines.append(\"Corrections applied:\")\n            for i, correction in enumerate(candidate.corrections, 1):\n                lines.append(\n                    f\"  {i}. [{correction.correction_type.name}] \"\n                    f\"'{correction.original}' \u2192 '{correction.replacement}'\"\n                )\n                if correction.description:\n                    lines.append(f\"     {correction.description}\")\n\n        if candidate.validated:\n            lines.append(\"\")\n            lines.append(f\"Validated: {candidate.validation_result or 'No result'}\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector--with-custom-configuration","title":"With custom configuration","text":"<p>config = CorrectorConfig(max_candidates=50) corrector = ChemNameCorrector(config)</p>"},{"location":"reference/#cholla_chem.ChemNameCorrector--with-external-validation","title":"With external validation","text":"<p>validator = PubChemValidator() results = corrector.correct(\"asprin\", validator=validator)</p>"},{"location":"reference/#cholla_chem.ChemNameCorrector.__init__","title":"<code>__init__(config=None, strategies=None)</code>","text":"<p>Initialize the chemical name corrector.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[CorrectorConfig]</code> <p>Configuration object (uses defaults if None)</p> <code>None</code> <code>strategies</code> <code>Optional[List[CorrectionStrategy]]</code> <p>Custom list of strategies (uses defaults if None)</p> <code>None</code> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[CorrectorConfig] = None,\n    strategies: Optional[List[CorrectionStrategy]] = None,\n):\n    \"\"\"\n    Initialize the chemical name corrector.\n\n    Args:\n        config: Configuration object (uses defaults if None)\n        strategies: Custom list of strategies (uses defaults if None)\n    \"\"\"\n    self.config = config or CorrectorConfig()\n    self.scorer = ChemicalNameScorer(self.config)\n\n    if strategies is not None:\n        self.strategies = strategies\n    else:\n        self.strategies = self._create_default_strategies()\n\n    self.validator = None\n    if self.config.enable_external_validation:\n        self.validator = OPSINValidator()\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector.add_strategy","title":"<code>add_strategy(strategy)</code>","text":"<p>Add a custom correction strategy.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>CorrectionStrategy</code> <p>The strategy to add</p> required Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def add_strategy(self, strategy: CorrectionStrategy) -&gt; None:\n    \"\"\"\n    Add a custom correction strategy.\n\n    Args:\n        strategy: The strategy to add\n    \"\"\"\n    self.strategies.append(strategy)\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector.correct","title":"<code>correct(name, use_validator=True, validate_all=False)</code>","text":"<p>Correct a chemical name and return ranked candidates.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The chemical name to correct</p> required <code>use_validator</code> <code>bool</code> <p>Whether to use external validator</p> <code>True</code> <code>validate_all</code> <code>bool</code> <p>Whether to validate all candidates or just the top ones</p> <code>False</code> <p>Returns:</p> Type Description <code>List[CorrectionCandidate]</code> <p>List of CorrectionCandidate objects, sorted by score (descending)</p> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def correct(\n    self, name: str, use_validator: bool = True, validate_all: bool = False\n) -&gt; List[CorrectionCandidate]:\n    \"\"\"\n    Correct a chemical name and return ranked candidates.\n\n    Args:\n        name: The chemical name to correct\n        use_validator: Whether to use external validator\n        validate_all: Whether to validate all candidates or just the top ones\n\n    Returns:\n        List of CorrectionCandidate objects, sorted by score (descending)\n    \"\"\"\n    # Generate all candidates\n    candidates = self._generate_all_candidates(name)\n\n    # Remove duplicates while preserving best corrections\n    unique_candidates = self._deduplicate_candidates(candidates)\n\n    # Score all candidates\n    scored_candidates = [\n        self.scorer.score(candidate) for candidate in unique_candidates\n    ]\n\n    # Filter by minimum score threshold\n    filtered_candidates = [\n        c for c in scored_candidates if c.score &gt;= self.config.min_score_threshold\n    ]\n\n    # Sort by score (descending)\n    sorted_candidates = sorted(\n        filtered_candidates, key=lambda c: c.score, reverse=True\n    )\n\n    # Limit to max candidates\n    limited_candidates = sorted_candidates[: self.config.max_candidates]\n\n    if use_validator:\n        self._validate_candidates_batch(\n            {name: limited_candidates}, self.validator, validate_all\n        )\n\n        limited_candidates = sorted(\n            limited_candidates, key=lambda c: c.score, reverse=True\n        )\n\n    return limited_candidates\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector.correct_batch","title":"<code>correct_batch(names, use_validator=True, validate_all=False)</code>","text":"<p>Correct multiple chemical names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>List[str]</code> <p>List of chemical names to correct</p> required <code>use_validator</code> <code>bool</code> <p>Whether to use external validator</p> <code>True</code> <code>validate_all</code> <code>bool</code> <p>Whether to validate all candidates or just the top ones</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, List[CorrectionCandidate]]</code> <p>Dictionary mapping original names to their candidates</p> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def correct_batch(\n    self, names: List[str], use_validator: bool = True, validate_all: bool = False\n) -&gt; Dict[str, List[CorrectionCandidate]]:\n    \"\"\"\n    Correct multiple chemical names.\n\n    Args:\n        names: List of chemical names to correct\n        use_validator: Whether to use external validator\n        validate_all: Whether to validate all candidates or just the top ones\n\n    Returns:\n        Dictionary mapping original names to their candidates\n    \"\"\"\n    results = {}\n    for name in names:\n        results[name] = self.correct(name, use_validator=False)\n\n    if use_validator:\n        self._validate_candidates_batch(results, self.validator, validate_all)\n\n    for name in names:\n        results[name] = sorted(results[name], key=lambda c: c.score, reverse=True)\n\n    return results\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector.explain_corrections","title":"<code>explain_corrections(candidate)</code>","text":"<p>Generate a human-readable explanation of corrections.</p> <p>Parameters:</p> Name Type Description Default <code>candidate</code> <code>CorrectionCandidate</code> <p>The candidate to explain</p> required <p>Returns:</p> Type Description <code>str</code> <p>Multi-line string explaining all corrections</p> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def explain_corrections(self, candidate: CorrectionCandidate) -&gt; str:\n    \"\"\"\n    Generate a human-readable explanation of corrections.\n\n    Args:\n        candidate: The candidate to explain\n\n    Returns:\n        Multi-line string explaining all corrections\n    \"\"\"\n    lines = [\n        f\"Original: {candidate.original_name}\",\n        f\"Corrected: {candidate.name}\",\n        f\"Score: {candidate.score:.3f}\",\n        f\"Number of corrections: {candidate.num_corrections}\",\n        \"\",\n        \"Score components:\",\n    ]\n\n    for component, value in candidate.score_components.items():\n        lines.append(f\"  - {component}: {value:.3f}\")\n\n    if candidate.corrections:\n        lines.append(\"\")\n        lines.append(\"Corrections applied:\")\n        for i, correction in enumerate(candidate.corrections, 1):\n            lines.append(\n                f\"  {i}. [{correction.correction_type.name}] \"\n                f\"'{correction.original}' \u2192 '{correction.replacement}'\"\n            )\n            if correction.description:\n                lines.append(f\"     {correction.description}\")\n\n    if candidate.validated:\n        lines.append(\"\")\n        lines.append(f\"Validated: {candidate.validation_result or 'No result'}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector.get_best_candidate","title":"<code>get_best_candidate(name, use_validator=True)</code>","text":"<p>Get the single best correction candidate.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Chemical name to correct</p> required <code>validator</code> <p>Optional external validator</p> required <p>Returns:</p> Type Description <code>Optional[CorrectionCandidate]</code> <p>Best candidate, or None if no candidates found</p> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def get_best_candidate(\n    self, name: str, use_validator: bool = True\n) -&gt; Optional[CorrectionCandidate]:\n    \"\"\"\n    Get the single best correction candidate.\n\n    Args:\n        name: Chemical name to correct\n        validator: Optional external validator\n\n    Returns:\n        Best candidate, or None if no candidates found\n    \"\"\"\n    candidates = self.correct(name, use_validator)\n    return candidates[0] if candidates else None\n</code></pre>"},{"location":"reference/#cholla_chem.ChemNameCorrector.remove_strategy","title":"<code>remove_strategy(strategy_name)</code>","text":"<p>Remove a strategy by name.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_name</code> <code>str</code> <p>Name of the strategy to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if strategy was found and removed, False otherwise</p> Source code in <code>cholla_chem/name_manipulation/name_correction/name_corrector.py</code> <pre><code>def remove_strategy(self, strategy_name: str) -&gt; bool:\n    \"\"\"\n    Remove a strategy by name.\n\n    Args:\n        strategy_name: Name of the strategy to remove\n\n    Returns:\n        True if strategy was found and removed, False otherwise\n    \"\"\"\n    for i, strategy in enumerate(self.strategies):\n        if strategy.name == strategy_name:\n            self.strategies.pop(i)\n            return True\n    return False\n</code></pre>"},{"location":"reference/#cholla_chem.ChemSpiPyResolver","title":"<code>ChemSpiPyResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using chemspipy.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class ChemSpiPyResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using chemspipy.\n    \"\"\"\n\n    def __init__(\n        self, resolver_name: str, chemspider_api_key: str, resolver_weight: float = 3\n    ):\n        super().__init__(\"cirpy\", resolver_name, resolver_weight)\n        if chemspider_api_key:\n            if not isinstance(chemspider_api_key, str):\n                raise TypeError(\"Invalid input: chemspider_api_key must be a string.\")\n        self._chemspider_api_key = chemspider_api_key\n\n    def name_to_smiles(\n        self,\n        compound_name_list: List[str],\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using ChemSpiPy.\n        \"\"\"\n        resolved_names = name_to_smiles_chemspipy(\n            compound_name_list, self._chemspider_api_key\n        )\n        return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.ChemSpiPyResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>","text":"<p>Convert chemical names to SMILES using ChemSpiPy.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self,\n    compound_name_list: List[str],\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using ChemSpiPy.\n    \"\"\"\n    resolved_names = name_to_smiles_chemspipy(\n        compound_name_list, self._chemspider_api_key\n    )\n    return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.ChemicalNameResolver","title":"<code>ChemicalNameResolver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for chemical name-to-SMILES resolvers.</p> <p>Subclasses must implement the <code>name_to_smiles</code> method.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class ChemicalNameResolver(ABC):\n    \"\"\"\n    Abstract base class for chemical name-to-SMILES resolvers.\n\n    Subclasses must implement the `name_to_smiles` method.\n    \"\"\"\n\n    def __init__(self, resolver_type: str, resolver_name: str, resolver_weight: float):\n        if not isinstance(resolver_type, str):\n            raise TypeError(\"Invalid input: resolver_type must be a string.\")\n        self._resolver_type: str = resolver_type\n        if not isinstance(resolver_name, str):\n            raise TypeError(\"Invalid input: resolver_name must be a string.\")\n        self._resolver_name: str = resolver_name\n        if not isinstance(resolver_weight, (int, float)):\n            raise TypeError(\n                \"Invalid input: resolver_weight must be a number between 0-1000.\"\n            )\n        if resolver_weight &lt; 0 or resolver_weight &gt; 1000:\n            raise ValueError(\n                \"Invalid input: resolver_weight must be a number between 0-1000.\"\n            )\n        self._resolver_weight: float = float(resolver_weight)\n\n    @property\n    def resolver_name(self) -&gt; str:\n        \"\"\"Return resolver_name.\"\"\"\n        return self._resolver_name\n\n    @property\n    def resolver_weight(self) -&gt; float:\n        \"\"\"Return resolver_weight.\"\"\"\n        return self._resolver_weight\n\n    @abstractmethod\n    def name_to_smiles(\n        self, compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES strings.\n\n        Args:\n            compound_name_list: List of chemical names.\n\n        Returns:\n            Tuple of:\n                - Dict mapping successful names to SMILES.\n                - Dict mapping failed names to error messages.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#cholla_chem.ChemicalNameResolver.resolver_name","title":"<code>resolver_name</code>  <code>property</code>","text":"<p>Return resolver_name.</p>"},{"location":"reference/#cholla_chem.ChemicalNameResolver.resolver_weight","title":"<code>resolver_weight</code>  <code>property</code>","text":"<p>Return resolver_weight.</p>"},{"location":"reference/#cholla_chem.ChemicalNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>  <code>abstractmethod</code>","text":"<p>Convert chemical names to SMILES strings.</p> <p>Parameters:</p> Name Type Description Default <code>compound_name_list</code> <code>List[str]</code> <p>List of chemical names.</p> required <p>Returns:</p> Type Description <code>Tuple[Dict[str, str], Dict[str, str]]</code> <p>Tuple of: - Dict mapping successful names to SMILES. - Dict mapping failed names to error messages.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>@abstractmethod\ndef name_to_smiles(\n    self, compound_name_list: List[str]\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES strings.\n\n    Args:\n        compound_name_list: List of chemical names.\n\n    Returns:\n        Tuple of:\n            - Dict mapping successful names to SMILES.\n            - Dict mapping failed names to error messages.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#cholla_chem.CorrectorConfig","title":"<code>CorrectorConfig</code>  <code>dataclass</code>","text":"<p>Configuration for the ChemNameCorrector.</p> <p>Attributes:</p> Name Type Description <code>max_candidates</code> <code>int</code> <p>Maximum number of candidates to generate</p> <code>max_corrections_per_candidate</code> <code>int</code> <p>Maximum corrections per candidate</p> <code>min_score_threshold</code> <code>float</code> <p>Minimum score to include candidate in results</p> <code>enable_character_substitution</code> <code>bool</code> <p>Enable OCR character correction</p> <code>max_character_substitution_edits</code> <code>int</code> <p>Max number of substitution edits</p> <code>enable_punctuation_restoration</code> <code>bool</code> <p>Enable missing punctuation detection</p> <code>enable_bracket_balancing</code> <code>bool</code> <p>Enable bracket matching correction</p> <code>custom_substitutions</code> <code>Dict[str, List[str]]</code> <p>Additional user-defined substitution rules</p> <code>custom_rules</code> <code>List[CorrectionRule]</code> <p>Additional user-defined correction rules</p> <code>enable_external_validation</code> <code>bool</code> <p>Enable external validation of candidates</p> Source code in <code>cholla_chem/name_manipulation/name_correction/dataclasses.py</code> <pre><code>@dataclass\nclass CorrectorConfig:\n    \"\"\"\n    Configuration for the ChemNameCorrector.\n\n    Attributes:\n        max_candidates: Maximum number of candidates to generate\n        max_corrections_per_candidate: Maximum corrections per candidate\n        min_score_threshold: Minimum score to include candidate in results\n        enable_character_substitution: Enable OCR character correction\n        max_character_substitution_edits: Max number of substitution edits\n        enable_punctuation_restoration: Enable missing punctuation detection\n        enable_bracket_balancing: Enable bracket matching correction\n        custom_substitutions: Additional user-defined substitution rules\n        custom_rules: Additional user-defined correction rules\n        enable_external_validation: Enable external validation of candidates\n    \"\"\"\n\n    max_candidates: int = 100\n    max_corrections_per_candidate: int = 5\n    min_score_threshold: float = 0.1\n    enable_locant_correction: bool = True\n    enable_character_substitution: bool = True\n    max_character_substitution_edits: int = 1\n    enable_punctuation_restoration: bool = False\n    enable_bracket_balancing: bool = False\n    custom_substitutions: Dict[str, List[str]] = field(default_factory=dict)\n    custom_rules: List[CorrectionRule] = field(default_factory=list)\n    enable_external_validation: bool = True\n</code></pre>"},{"location":"reference/#cholla_chem.InorganicShorthandNameResolver","title":"<code>InorganicShorthandNameResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using inorganic shorthand (e.g. [Cp*RhCl2]2).</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class InorganicShorthandNameResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using inorganic shorthand (e.g. [Cp*RhCl2]2).\n    \"\"\"\n\n    def __init__(self, resolver_name: str, resolver_weight: float = 2):\n        super().__init__(\"inorganic_shorthand\", resolver_name, resolver_weight)\n\n    def name_to_smiles(\n        self, compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using inorganic shorthand converter.\n        \"\"\"\n        resolved_names = name_to_smiles_inorganic_shorthand(compound_name_list)\n        return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.InorganicShorthandNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>","text":"<p>Convert chemical names to SMILES using inorganic shorthand converter.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self, compound_name_list: List[str]\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using inorganic shorthand converter.\n    \"\"\"\n    resolved_names = name_to_smiles_inorganic_shorthand(compound_name_list)\n    return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.ManualNameResolver","title":"<code>ManualNameResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using manually curated names and corresponding SMILES.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class ManualNameResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using manually curated names and corresponding SMILES.\n    \"\"\"\n\n    def __init__(\n        self,\n        resolver_name: str,\n        provided_name_dict: dict | None = None,\n        resolver_weight: float = 10,\n    ):\n        super().__init__(\"manual\", resolver_name, resolver_weight)\n        if provided_name_dict:\n            if not isinstance(provided_name_dict, dict):\n                raise TypeError(\n                    \"Invalid input: provided_name_dict must be a dictionary.\"\n                )\n            for k, v in provided_name_dict.items():\n                if not isinstance(k, str) or not isinstance(v, str):\n                    raise ValueError(\n                        \"Invalid input: keys and values in provided_name_dict must be strings.\"\n                    )\n\n        self._provided_name_dict = provided_name_dict\n\n    def name_to_smiles(\n        self,\n        compound_name_list: List[str],\n        provided_name_dict: Dict[str, str] | None = None,\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using manual name database.\n        \"\"\"\n        if provided_name_dict is None:\n            provided_name_dict = self._provided_name_dict\n        resolved_names = name_to_smiles_manual(compound_name_list, provided_name_dict)\n        return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.ManualNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list, provided_name_dict=None)</code>","text":"<p>Convert chemical names to SMILES using manual name database.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self,\n    compound_name_list: List[str],\n    provided_name_dict: Dict[str, str] | None = None,\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using manual name database.\n    \"\"\"\n    if provided_name_dict is None:\n        provided_name_dict = self._provided_name_dict\n    resolved_names = name_to_smiles_manual(compound_name_list, provided_name_dict)\n    return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.OpsinNameResolver","title":"<code>OpsinNameResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using OPSIN via py2opsin.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class OpsinNameResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using OPSIN via py2opsin.\n    \"\"\"\n\n    def __init__(\n        self,\n        resolver_name: str,\n        resolver_weight: float = 3,\n        allow_acid: bool = False,\n        allow_radicals: bool = True,\n        allow_bad_stereo: bool = False,\n        wildcard_radicals: bool = False,\n        jar_fpath: str = \"opsin-cli.jar\",\n    ):\n        super().__init__(\"opsin\", resolver_name, resolver_weight)\n        self._allow_acid = allow_acid\n        self._allow_radicals = allow_radicals\n        self._allow_bad_stereo = allow_bad_stereo\n        self._wildcard_radicals = wildcard_radicals\n\n    def name_to_smiles(\n        self, compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using OPSIN.\n        \"\"\"\n        resolved_names, failure_message_dict = name_to_smiles_opsin(\n            compound_name_list,\n            allow_acid=self._allow_acid,\n            allow_radicals=self._allow_radicals,\n            allow_bad_stereo=self._allow_bad_stereo,\n            wildcard_radicals=self._wildcard_radicals,\n        )\n        return resolved_names, failure_message_dict\n</code></pre>"},{"location":"reference/#cholla_chem.OpsinNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>","text":"<p>Convert chemical names to SMILES using OPSIN.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self, compound_name_list: List[str]\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using OPSIN.\n    \"\"\"\n    resolved_names, failure_message_dict = name_to_smiles_opsin(\n        compound_name_list,\n        allow_acid=self._allow_acid,\n        allow_radicals=self._allow_radicals,\n        allow_bad_stereo=self._allow_bad_stereo,\n        wildcard_radicals=self._wildcard_radicals,\n    )\n    return resolved_names, failure_message_dict\n</code></pre>"},{"location":"reference/#cholla_chem.PubChemNameResolver","title":"<code>PubChemNameResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using PubChem via PubChemPy.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class PubChemNameResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using PubChem via PubChemPy.\n    \"\"\"\n\n    def __init__(self, resolver_name: str, resolver_weight: float = 2):\n        super().__init__(\"pubchem\", resolver_name, resolver_weight)\n\n    def name_to_smiles(\n        self, compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using pubchem.\n        \"\"\"\n        resolved_names = name_to_smiles_pubchem(compound_name_list)\n        return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.PubChemNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>","text":"<p>Convert chemical names to SMILES using pubchem.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self, compound_name_list: List[str]\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using pubchem.\n    \"\"\"\n    resolved_names = name_to_smiles_pubchem(compound_name_list)\n    return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.StructuralFormulaNameResolver","title":"<code>StructuralFormulaNameResolver</code>","text":"<p>               Bases: <code>ChemicalNameResolver</code></p> <p>Resolver using structural chemical formula (e.g. CH3CH2CH2COOH).</p> Source code in <code>cholla_chem/main.py</code> <pre><code>class StructuralFormulaNameResolver(ChemicalNameResolver):\n    \"\"\"\n    Resolver using structural chemical formula (e.g. CH3CH2CH2COOH).\n    \"\"\"\n\n    def __init__(self, resolver_name: str, resolver_weight: float = 2):\n        super().__init__(\"structural_formula\", resolver_name, resolver_weight)\n\n    def name_to_smiles(\n        self, compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Convert chemical names to SMILES using structural formula converter.\n        \"\"\"\n        resolved_names = name_to_smiles_structural_formula(compound_name_list)\n        return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.StructuralFormulaNameResolver.name_to_smiles","title":"<code>name_to_smiles(compound_name_list)</code>","text":"<p>Convert chemical names to SMILES using structural formula converter.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def name_to_smiles(\n    self, compound_name_list: List[str]\n) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n    \"\"\"\n    Convert chemical names to SMILES using structural formula converter.\n    \"\"\"\n    resolved_names = name_to_smiles_structural_formula(compound_name_list)\n    return resolved_names, {}\n</code></pre>"},{"location":"reference/#cholla_chem.resolve_compounds_to_smiles","title":"<code>resolve_compounds_to_smiles(compounds_list, resolvers_list=[], smiles_selection_mode='weighted', detailed_name_dict=False, batch_size=500, normalize_unicode=True, split_names_to_solve=True, resolve_peptide_shorthand=True, attempt_name_correction=True, name_correction_config=None)</code>","text":"<p>Resolve a list of compound names to their SMILES representations.</p> <p>Parameters:</p> Name Type Description Default <code>compounds_list</code> <code>List[str]</code> <p>A list of compound names.</p> required <code>resolvers_list</code> <code>List[ChemicalNameResolver]</code> <p>A list of ChemicalNameResolver instances. Defaults to [].</p> <code>[]</code> <code>smiles_selection_mode</code> <code>str</code> <p>The method to select the SMILES representation from multiple resolvers. Defaults to 'weighted'.</p> <code>'weighted'</code> <code>detailed_name_dict</code> <code>bool</code> <p>If True, returns a dictionary with detailed information about each compound. Defaults to False.</p> <code>False</code> <code>batch_size</code> <code>int</code> <p>The number of compounds to process in each batch. Defaults to 500.</p> <code>500</code> <code>normalize_unicode</code> <code>bool</code> <p>Whether to normalize Unicode characters in compound names. Defaults to True.</p> <code>True</code> <code>split_names_to_solve</code> <code>bool</code> <p>Whether to split compound names on common delimiters to solve them as separate compounds. Can be used to solve otherwise unresolvable compound names such as BH3\u2022THF. Defaults to True.</p> <code>True</code> <code>resolve_peptide_shorthand</code> <code>bool</code> <p>Whether to resolve peptide shorthand notation. Defaults to True.</p> <code>True</code> <code>attempt_name_correction</code> <code>bool</code> <p>Whether to attempt to correct compound names that are misspelled or contain typos. Defaults to True.</p> <code>True</code> <code>name_correction_config</code> <code>bool</code> <p>Configuration for name correction. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Dict[str, List[str]]]] | Dict[str, str]</code> <p>Dict[str, Dict[str, Dict[str, List[str]]]] | Dict[str, str]: A dictionary mapping each compound to its SMILES representation and resolvers, or a simple dictionary mapping each compound to it's selected SMILES representation.</p> Source code in <code>cholla_chem/main.py</code> <pre><code>def resolve_compounds_to_smiles(\n    compounds_list: List[str],\n    resolvers_list: List[ChemicalNameResolver] = [],\n    smiles_selection_mode: str = \"weighted\",\n    detailed_name_dict: bool = False,\n    batch_size: int = 500,\n    normalize_unicode: bool = True,\n    split_names_to_solve: bool = True,\n    resolve_peptide_shorthand: bool = True,\n    attempt_name_correction: bool = True,\n    name_correction_config: Optional[CorrectorConfig] = None,\n) -&gt; Dict[str, Dict[str, Dict[str, List[str]]]] | Dict[str, str]:\n    \"\"\"\n    Resolve a list of compound names to their SMILES representations.\n\n    Args:\n        compounds_list (List[str]): A list of compound names.\n        resolvers_list (List[ChemicalNameResolver], optional): A list of ChemicalNameResolver instances.\n            Defaults to [].\n        smiles_selection_mode (str, optional): The method to select the SMILES representation from multiple resolvers.\n            Defaults to 'weighted'.\n        detailed_name_dict (bool, optional): If True, returns a dictionary with detailed information about each compound.\n            Defaults to False.\n        batch_size (int, optional): The number of compounds to process in each batch. Defaults to 500.\n        normalize_unicode (bool, optional): Whether to normalize Unicode characters in compound names. Defaults to True.\n        split_names_to_solve (bool, optional): Whether to split compound names on common delimiters to solve them as separate compounds.\n            Can be used to solve otherwise unresolvable compound names such as BH3\u2022THF. Defaults to True.\n        resolve_peptide_shorthand (bool, optional): Whether to resolve peptide shorthand notation. Defaults to True.\n        attempt_name_correction (bool, optional): Whether to attempt to correct compound names that are misspelled or contain typos.\n            Defaults to True.\n        name_correction_config (bool, optional): Configuration for name correction. Defaults to None.\n\n    Returns:\n        Dict[str, Dict[str, Dict[str, List[str]]]] | Dict[str, str]: A dictionary mapping each compound to its SMILES representation and resolvers, or a simple dictionary mapping each compound to it's selected SMILES representation.\n    \"\"\"\n    if not resolvers_list:\n        resolvers_list = [\n            PubChemNameResolver(\"pubchem_default\"),\n            OpsinNameResolver(\"opsin_default\"),\n            ManualNameResolver(\"manual_default\"),\n            StructuralFormulaNameResolver(\"structural_formula_default\"),\n            InorganicShorthandNameResolver(\"inorganic_shorthand_default\"),\n        ]\n\n    if isinstance(compounds_list, str):\n        compounds_list = [compounds_list]\n    if not isinstance(compounds_list, list):\n        raise ValueError(\n            \"Invalid input: compounds_list must be a string or a non-empty list of strings.\"\n        )\n    if isinstance(compounds_list, list):\n        if len(compounds_list) == 0:\n            raise ValueError(\n                \"Invalid input: compounds_list must be a string or a non-empty list of strings.\"\n            )\n        for compound in compounds_list:\n            if not isinstance(compound, str):\n                raise ValueError(\n                    \"Invalid input: compounds_list must be a string or a non-empty list of strings.\"\n                )\n    if len(compounds_list) != len(set(compounds_list)):\n        logger.warning(\"Removing duplicate compound names from compounds_list.\")\n        compounds_list = list(set(compounds_list))\n\n    if not isinstance(resolvers_list, list) or len(resolvers_list) == 0:\n        raise ValueError(\n            \"Invalid input: resolvers_list must be a non-empty list of ChemicalNameResolver instances.\"\n        )\n\n    seen_resolvers = []\n    for resolver in resolvers_list:\n        if not isinstance(resolver, ChemicalNameResolver):\n            raise ValueError(\n                f\"Invalid resolver: {resolver} is not an instance of ChemicalNameResolver.\"\n            )\n        if resolver.resolver_name in seen_resolvers:\n            raise ValueError(f\"Duplicate resolver name: {resolver.resolver_name}.\")\n        seen_resolvers.append(resolver.resolver_name)\n\n    if not (isinstance(smiles_selection_mode, str) or callable(smiles_selection_mode)):\n        raise ValueError(\n            \"Invalid input: smiles_selection_mode must be a string or function.\"\n        )\n\n    if not isinstance(detailed_name_dict, bool):\n        raise ValueError(\"Invalid input: detailed_name_dict must be a bool.\")\n\n    if not isinstance(batch_size, int):\n        raise TypeError(\"Invalid input: batch_size must be an integer.\")\n    if batch_size &lt;= 0 or batch_size &gt; 1000:\n        raise ValueError(\"Invalid input: batch_size must be an integer between 1-1000.\")\n\n    if not isinstance(split_names_to_solve, bool):\n        raise ValueError(\"Invalid input: split_names_to_solve must be a bool.\")\n\n    if not isinstance(normalize_unicode, bool):\n        raise ValueError(\"Invalid input: normalize_unicode must be a bool.\")\n\n    if normalize_unicode:\n        # Clean compound names (strip, remove/replace forbidden characters, etc.) and return a mapping dict\n        cleaned_compounds_list, cleaned_compounds_dict = (\n            normalize_unicode_and_return_mapping(compounds_list)\n        )\n    else:\n        cleaned_compounds_list = compounds_list\n        cleaned_compounds_dict = {compound: compound for compound in compounds_list}\n\n    if split_names_to_solve:\n        # Split compound names on delimiters, add split parts to compounds list\n        # Return mapping between original compound names and split parts\n        # Necessary to resolve names like H\u2082O\u2022THF\n        cleaned_compounds_list, delimiter_split_dict = (\n            split_compounds_on_delimiters_and_return_mapping(cleaned_compounds_list)\n        )\n\n    # Resolve compounds and split compound names with resolvers\n    resolvers_out_dict = resolve_compounds_using_resolvers(\n        cleaned_compounds_list, resolvers_list, batch_size\n    )\n\n    # Assemble the resolution dictionary\n    compounds_out_dict = assemble_compounds_resolution_dict(\n        compounds_list, resolvers_out_dict, cleaned_compounds_dict\n    )\n\n    if split_names_to_solve:\n        # Resolve compounds that were split with split_compounds_on_delimiters_and_return_mapping\n        compounds_out_dict = assemble_split_compounds_resolution_dict(\n            compounds_out_dict,\n            compounds_list,\n            resolvers_out_dict,\n            cleaned_compounds_dict,\n            delimiter_split_dict,\n        )\n\n    # Get the resolvers weight dict - needed for SMILESSelector\n    resolvers_weight_dict = get_resolvers_weight_dict(resolvers_list)\n    resolvers_priority_order = [resolver.resolver_name for resolver in resolvers_list]\n\n    # Select \"best\" SMILES according to some criteria, add to resolution dict\n    compounds_out_dict = select_smiles_with_criteria(\n        compounds_out_dict,\n        resolvers_weight_dict,\n        resolvers_priority_order,\n        smiles_selection_mode,\n    )\n\n    if attempt_name_correction:\n        # Attempt to correct compound names and then resolve them again.\n        corrected_names_dict = correct_names(\n            compounds_out_dict, name_correction_config, resolve_peptide_shorthand\n        )\n        if corrected_names_dict:\n            corrected_names_dict_list = [\n                ele[\"selected_name\"] for ele in list(corrected_names_dict.values())\n            ]\n            corrected_names_original_names_mapping_dict = {\n                v[\"selected_name\"]: k for k, v in list(corrected_names_dict.items())\n            }\n            corrected_compounds_out_dict = resolve_compounds_to_smiles(\n                compounds_list=corrected_names_dict_list,\n                resolvers_list=resolvers_list,\n                smiles_selection_mode=smiles_selection_mode,\n                detailed_name_dict=True,  # Need detailed name dict\n                batch_size=batch_size,\n                normalize_unicode=normalize_unicode,\n                split_names_to_solve=split_names_to_solve,\n                resolve_peptide_shorthand=False,  # Prevent recursion\n                attempt_name_correction=False,  # Prevent recursion\n            )\n            for k, v in corrected_names_original_names_mapping_dict.items():\n                if k in corrected_compounds_out_dict:\n                    compounds_out_dict[v] = corrected_compounds_out_dict[k]\n                    compounds_out_dict[v][\"name_correction_info\"] = (\n                        corrected_names_dict[v]\n                    )\n\n    if not detailed_name_dict:\n        return {k: v.get(\"SMILES\", \"\") for k, v in compounds_out_dict.items()}\n\n    return compounds_out_dict\n</code></pre>"},{"location":"resolvers/","title":"Resolvers","text":"<p>Cholla uses a variety of resolvers to convert chemical names to SMILES. Resolvers can be initialized and passed to the function resolve_compounds_to_smiles as a list to customize how compounds are resolved to SMILES. If no resolvers are passed, the following default resolvers will be used:</p> <ul> <li>PubChemNameResolver('pubchem_default', resolver_weight=2),</li> <li>OpsinNameResolver('opsin_default', resolver_weight=3),</li> <li>ManualNameResolver('manual_default', resolver_weight=10),</li> <li>StructuralFormulaNameResolver('structural_formula_default', resolver_weight=2)</li> <li>InorganicShorthandNameResolver('inorganic_shorthand_default', resolver_weight=2)</li> </ul>"},{"location":"resolvers/#passing-resolvers-to-resolve_compounds_to_smiles","title":"Passing Resolvers to resolve_compounds_to_smiles:","text":"<p>Initialize resolvers with a name (required), and resolver_weight (optional): <pre><code>from cholla_chem import resolve_compounds_to_smiles\nfrom cholla_chem import (\n    OpsinNameResolver, \n    PubChemNameResolver, \n    CIRpyNameResolver\n)\n\nopsin_resolver = OpsinNameResolver(\n    resolver_name='opsin', \n    resolver_weight=4\n)\npubchem_resolver =  PubChemNameResolver(\n    resolver_name='pubchem', \n    resolver_weight=3\n)\ncirpy_resolver = CIRpyNameResolver(\n    resolver_name='cirpy', \n    resolver_weight=2\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['2-acetyloxybenzoic acid'],\n    [opsin_resolver, pubchem_resolver, cirpy_resolver],\n    detailed_name_dict=True\n)\n\n\"{'2-acetyloxybenzoic acid': {\n    'SMILES': 'CC(=O)Oc1ccccc1C(=O)O',\n    'SMILES_source': ['opsin', 'pubchem', 'cirpy'],\n    'SMILES_dict': {\n        'CC(=O)Oc1ccccc1C(=O)O': ['opsin', 'pubchem', 'cirpy']\n    },\n    'info_messages': {}\n}}\"\n</code></pre></p>"},{"location":"resolvers/#opsinnameresolver","title":"OpsinNameResolver","text":"<p>This resolver uses a fork of the py2opsin library that returns the error message from OPSIN if a name cannot be resolved. This resolver can be configured with the following arguments:</p> <p>Arguments:</p> <ul> <li>allow_acid (bool, optional): Allow interpretation of acids. Defaults to False.</li> <li>allow_radicals (bool, optional): Enable radical interpretation. Defaults to False.</li> <li>allow_bad_stereo (bool, optional): Allow OPSIN to ignore uninterpreatable stereochem. Defaults to False.</li> <li>wildcard_radicals (bool, optional): Output radicals as wildcards. Defaults to False.</li> </ul> <p>Default weight for 'weighted' SMILES selection method: 3</p> <pre><code>from cholla_chem import OpsinNameResolver\n\nopsin_resolver = OpsinNameResolver(\n    resolver_name='opsin',\n    resolver_weight=3,\n    allow_acid=False,\n    allow_radicals: True,\n    allow_bad_stereo: False,\n    wildcard_radicals: False\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['2-acetyloxybenzoic acid'], \n    [opsin_resolver]\n)\n</code></pre>"},{"location":"resolvers/#pubchemnameresolver","title":"PubChemNameResolver","text":"<p>This resolver uses a fork of the PubChemPy library which implements batching with the Power User Gateway XML schema to significantly speedup SMILES resolutions.</p> <p>Default weight for 'weighted' SMILES selection method: 2</p> <pre><code>from cholla_chem import PubChemNameResolver\n\npubchem_resolver = PubChemNameResolver(\n    resolver_name='pubchem', \n    resolver_weight=2\n)\n\nresolved_smiles = resolve_compounds_to_smiles(['acetone'], [pubchem_resolver])\n</code></pre>"},{"location":"resolvers/#cirpynameresolver","title":"CIRpyNameResolver","text":"<p>This resolver uses the python library CIRpy, a Python interface for the Chemical Identifier Resolver (CIR) by the CADD Group at the NCI/NIH.</p> <p>Default weight for 'weighted' SMILES selection method: 1</p> <pre><code>from cholla_chem import CIRpyNameResolver\n\ncirpy_resolver = CIRpyNameResolver(\n    resolver_name='cirpy', \n    resolver_weight=1\n)\n\nresolved_smiles = resolve_compounds_to_smiles(['acetone'], [cirpy_resolver])\n</code></pre>"},{"location":"resolvers/#chemspipynameresolver","title":"ChemSpiPyNameResolver","text":"<p>This resolver uses the python library ChemSpiPy, a Python interface for the ChemSpider API by the RSC. This resolver must be initialized with a ChemSpider API key, which can be obtained here.</p> <p>Default weight for 'weighted' SMILES selection method: 3</p> <pre><code>from cholla_chem import ChemSpiPyNameResolver\n\nchemspider_resolver = ChemSpiPyNameResolver(\n    resolver_name='chemspider', \n    resolver_weight=3,\n    chemspider_api_key='CHEMSPIDER_API_KEY'\n)\n\nresolved_smiles = resolve_compounds_to_smiles(['acetone'], [chemspider_resolver])\n</code></pre>"},{"location":"resolvers/#manualnameresolver","title":"ManualNameResolver","text":"<p>This resolver uses a dataset of manually curated names and their corresponding SMILES, especially focused on common names that are incorrectly resolved by other resolvers (e.g. 'NaH').</p> <p>Default weight for 'weighted' SMILES selection method: 10</p> <pre><code>from cholla_chem import ManualNameResolver\n\nmanual_resolver = ManualNameResolver(\n    resolver_name='manual', \n    resolver_weight=10\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['NaH'], \n    [manual_resolver]\n)\n</code></pre> <p>ManualNameResolver can also be initialized with a custom dictionary mapping chemical names to SMILES: <pre><code>from cholla_chem import ManualNameResolver\n\ncustom_name_dict = {'Foobar': 'c1ccccc1'}\n\nmanual_resolver = ManualNameResolver(\n    resolver_name='manual', \n    resolver_weight=10,\n    provided_name_dict=custom_name_dict\n)\n\nresolved_smiles = resolve_compounds_to_smiles(['Foobar'], [manual_resolver])\n</code></pre></p>"},{"location":"resolvers/#structuralformulanameresolver","title":"StructuralFormulaNameResolver","text":"<p>This resolver converts simple structural chemical formulas (e.g. 'CH3CH2CH2COOH') to SMILES.</p> <p>Default weight for 'weighted' SMILES selection method: 2</p> <pre><code>from cholla_chem import StructuralFormulaNameResolver\n\nstructural_formula_resolver = StructuralFormulaNameResolver(\n    resolver_name='structural_formula', \n    resolver_weight=2\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['CH3CH2CH2COOH'], \n    [structural_formula_resolver]\n)\n</code></pre>"},{"location":"resolvers/#inorganicshorthandnameresolver","title":"InorganicShorthandNameResolver","text":"<p>This resolver converts inorganic chemical formulas (e.g. '[Cp*RhCl2]2') to SMILES.</p> <p>Default weight for 'weighted' SMILES selection method: 2</p> <pre><code>from cholla_chem import InorganicShorthandNameResolver\n\ninorganic_shorthand_resolver = InorganicShorthandNameResolver(\n    resolver_name='inorganic_shorthand', \n    resolver_weight=2\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['[Cp*RhCl2]2'], \n    [inorganic_shorthand_resolver]\n)\n</code></pre>"},{"location":"resolvers/#custom-resolvers","title":"Custom Resolvers","text":"<p>This library also supports using custom resolvers. To use a custom resolver, import the base class ChemicalNameResolver, and create a subclass with the format shown below. The name_to_smiles method is used to resolve compound names to SMILES. In this example, the method resolves names using a simple lookup dictionary, but it can be also used to call an API, use other name-to-SMILES libraries, run an algorithm, etc. This method must return a tuple of dictionaries, where the first dictionary maps chemical names (strings) to SMILES (strings). The second dictionary returns information (e.g. errors in the resolution process) to the detailed_name_dict by mapping chemical names (strings) to some message (strings).</p> <pre><code>from cholla_chem import resolve_compounds_to_smiles\nfrom cholla_chem import ChemicalNameResolver\n\nclass MyCustomResolver(ChemicalNameResolver):\n    \"\"\"\n    My custom resolver.\n    \"\"\"\n\n    def __init__(self, resolver_name: str, resolver_weight: float = 1):\n        super().__init__(\"example\", resolver_name, resolver_weight)\n\n    def name_to_smiles(\n        self,\n        compound_name_list: List[str]\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Lookup chemical names from a dict.\n        \"\"\"\n        lookup_dict = {\n            'benzene': 'c1ccccc1'\n        }\n\n        resolved_names_dict = {}\n        info_messages_dict = {}\n        for compound_name in compound_name_list:\n            resolved_smiles = lookup_dict.get(compound_name, '')\n            resolved_names_dict[compound_name] = resolved_smiles\n            if not resolved_smiles:\n                info_messages_dict[compound_name] = 'Some info message.'\n\n        return resolved_names_dict, info_messages_dict\n\nmy_custom_resolver = MyCustomResolver(\n    resolver_name='example', \n    resolver_weight=1\n)\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['benzene', 'aspirin'], \n    [my_custom_resolver], \n    detailed_name_dict=True\n)\n\n\"{'benzene': {\n    'SMILES': 'c1ccccc1',\n    'SMILES_source': ['example'],\n    'SMILES_dict': {\n        'c1ccccc1': ['example']\n    },\n    'info_messages': {}\n},\n'aspirin': {\n    'SMILES': '',\n    'SMILES_source': [],\n    'SMILES_dict': {},\n    'info_messages': {\n        'example': 'Some info message.'\n    }\n}}\"\n</code></pre>"},{"location":"smiles_selection/","title":"Smiles Selection","text":"<p>When different resolvers disagree on the SMILES for a given compound, the SMILES selection method will be used to determine the \"best\" SMILES. Set smiles_selection_mode to any of the following in the resolve_compounds_to_smiles function (Default: 'weighted'):</p> <ul> <li>'consensus': Pick the SMILES string returned by the most resolvers. Tie-breaker: lexicographical order.</li> <li>'ordered': Pick the first SMILES that was generated by a resolver with the highest priority. The order of the resolvers provided as the resolvers_list argument in resolve_compounds_to_smiles determines the priority (highest to lowest).</li> <li>'weighted': Assign weights to resolvers. Sum weights per SMILES. Pick highest total. Custom weights can be assigned at resolver initialization. See Resolvers for default weights.</li> <li>'rdkit_standardized': Pick the SMILES that is most standardized by RDKit. Penalizes SMILES with more fragments, formal charges, radicals, and isotopes.</li> <li>'fewest_fragments': Pick the smiles with the fewest fragments (separated by '.')</li> <li>'longest_smiles': Pick the longest SMILES.</li> <li>'shorted_smiles': Pick the shortest SMILES.</li> <li>'random': Pick a random SMILES.</li> <li>'highest_symmetry': Pick the SMILES with the highest symmetry.</li> </ul>"},{"location":"smiles_selection/#custom-smiles-selection-functions","title":"Custom SMILES selection functions","text":"<p>You can also pass a function to resolve_compounds_to_smiles as the smiles_selection_mode to use custom selection functions. For example: <pre><code>from cholla_chem.main import resolve_compounds_to_smiles\nfrom typing import Dict, List, Tuple\n\ndef reverse_alphabetical(\n    smiles_dict: Dict[str, List[str]], \n    **kwargs\n) -&gt; Tuple[str, List[str]]:\n\n    smiles = sorted(smiles_dict.keys())[-1]\n    return smiles, smiles_dict[smiles]\n\nresolved_smiles = resolve_compounds_to_smiles(\n    ['aspirin'], \n    smiles_selection_mode=reverse_alphabetical\n)\n</code></pre></p>"}]}